# 6. 데이터 타입
- 원시 타입(primitive type)
    - number type: 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
        - 배정밀도 64비트 부동소수점 형식을 따름
        
        ```jsx
        // 모두 숫자 타입이다.
        var integer = 10;     // 정수
        var double = 10.12;   // 실수
        var negative = -20;   // 음의 정수
        
        var binary = 0b01000001;  // 2진수
        var octal = 0o101;     // 8진수
        var hex = 0x41;        // 16진수
        
        //표기법만 다를 뿐 모두 같은 값
        console.log(binary);  // 65
        console.log(octal);   // 65
        console.log(hex);     // 65
        console.log(binary === octal);   // true
        console.log(octal === hex);      // true
        ```
        
        - JS 숫자 타입은 정수만을 위한 타입이 없고 모두 수를 실수 처리함 → 정수로 표시했다고 하더라도 사실은 실수이다.
            
            ```jsx
            // 숫자 타입은 모두 실수로 처리된다.
            console.log(1 === 1.0);   // true
            console.log(4 / 2);    // 2
            console.log(3 / 2);    // 1.5
            ```
            
            - 숫자 타입은 추가적으로 세 가지의 특별한 값도 표현할 수 있다.
                - `Infinity` : 양의 무한대
                - `-Infinity` : 음의 무한대
                - `NaN` : 산술 연산 불가 (not-a-number)
                    - 대소문자 구별하므로, `Nan`, `NAN`, `nan`처럼 작성하면 에러가 발생한다. (값이 아닌 식별자로 해석하기 때문)
                        - ReferenceError 발생
                        
    - string type: 문자열
        - 텍스트 데이터를 나타내는 데 사용하는데, 문자열은 16비트 유니코드(UTF-16)의 집합으로, 전 세계 대부분의 문자를 표현할 수 있음
        
        ```jsx
        // 문자열은 작은 따옴표, 큰따옴표, 백틱으로 텍스트를 감쌀 수 있음
        // JS에선 일반적으로 작은 따옴표를 사용하여 문자열을 표기한다.
        var string;
        string = '문자열';   // 작은 따옴표
        string = "문자열";   // 큰따옴표
        string = `문자열`;   // 백틱(ES6)
        ```
        
        - 만약, 문자열을 따옴표로 감싸지 않으면 JS 엔진은 키워드나 식별자 같은 토큰으로 인식하게 된다. (ReferenceError)
        - 만약, 따옴표로 문자열을 감싸지 않는다면 스페이스와 같은 공백 문자도 포함시킬 수 없다.
        - 참고
            - C는 문자열 타입을 제공하지 않고 문자의 배열로 문자열을 표현하고
            - Java는 문자열을 객체로 표현한다.
            - 그러나, JS 문자열은 Primitive(원시 타입)이며, 변경 불가능한 값(Immutable value)이다.
                - 즉, 문자열이 생성됨년 그 문자열은 변경할 수 없다는 것을 의미
            
        - 템플릿 리터럴 (ES6)
            - 멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿((tagged template) 등 편리한 문자열 처리 기능을 제공하고, 런타임에 일반 문자열로 변환되어 처리됨
            - 템플릿 리터럴은 큰따옴표, 작은따옴표 대신에 백틱(`)을 사용해서 표현한다.
            
            ```jsx
            // 템플릿 리터럴 사용
            var template = `Template literal`;
            console.log(template);    // template literal
            ```
            
            1. 멀티라인 문자열
                - 일반 문자열 내에선, 줄바꿈(개행)이 허용되지 않음
                - 따라서, 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 함
                    - (대부분 비슷한데) 필요한 거만 적기
                    - `\uXXXX` : 유니코드, ex : `\u0041` : A, `\uD55C` : ‘한’, `\u{1F600}` : 😃
                    - `\n` : Line Feed, 다음 행으로 이동
                    - `\r` : Carrage Return, 커서를 처음으로 이동
                        - JS에서 라인 피드와 캐리지 리턴은 모두 개행을 의미하는데, 캐리지 리턴으로 개행을 사용하는 경우는 거의 없어서... 라인 피드로 개행을 사용한다.
                
                - 예를 들어서, 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 다음과 같이 이스케이프 시퀀스를 사용해 작성함
                    
                    ```jsx
                    var template = '<ul>\n\t<li><a href="#">Home</a></li\n</ul>';
                    console.log(template);
                    
                    // 하지만, 템플릿 리터럴에선 이스케이프 시퀀스를 사용하지 않고도 
                    // 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용됨
                    var template = `<ul>
                    	<li><a href="#">Home</a></li>
                    </ul>`;
                    
                    console.log(template);
                    ```
                    
            2. 표현식 삽입
                - 문자열은 문자열 연산자 `+`를 사용하여 연결할 수 있다. (ES5)
                
                ```jsx
                var first = 'Hello';
                var last = ' World';
                
                // ES5 : 문자열 연결
                console.log(first + last);   // Hello World
                ```
                
                - 템플릿 리터럴 내에선 표현식 삽입 (expression interpolation)을 통해 간단히 문자열을 삽입할 수 있다.
                    - 이를 통해서 가독성 높고 간편하게 문자열을 조합할 수 있음
                    
                    ```jsx
                    var first = 'hello';
                    var last = 'world';
                    
                    // ES6 : 표현식 삽입
                    // 표현식 삽입을 위해선 ${ }을 사용하여 표현식을 감싸야 함
                    console.log(`${first} ${last}`);   // hello world
                    ```
                    
                    - 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다.
                    
    - boolean type : true / false
    - undefined type : var 키워드로 선언된 변수에 암묵적으로 할당되는 값
        - `undefined` 타입의 값은 `undefined`가 유일함
        - var로 선언한 함수는 암묵적으로 `undefined`로 초기화 됨
            - 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 garbage value이 들어 있음)로 내버려두지 않고 JS 엔진이 `undefined`로 초기화한다.
            - 변수 선언 이후 값을 할당하지 않은 변수를 참조하면 `undefined`가 반환된다.
            
            ```jsx
            var foo;
            console.log(foo);    // undefined
            ```
            
            - `undefined`를 반환되면 초기화되지 않은 변수라는 것을 간파하면 된다. (의도적으로 `undefined`를 변수에 할당할 이유가 없음)
                - `undefined` 본래 취지에 어긋나고 혼란을 줄 수 있기 때문
            
            <aside>
            💡 JS(ECMAScript)에선 변수는 선언(declaration)한다고 표현하고, 함수는 정의(definition)한다고 표현한다. 
            
            `undefined`를 직역하면 ‘정의되지 않은’이다. JS에서의 정의는 변수에 값을 할당하여 변수의 실체를 명확히 하는 것이다.
            
            </aside>
            
    - null type : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
        - 참고 : `null` 외에 `Null`, `NULL` 등처럼 대소문자를 다르게 사용하면 ReferenceError 발생
        - `null`은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 ; intentional absence)할 때 사용한다.
            - 변수에 `null`을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
            - 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, JS 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것
        
        ```jsx
        var foo = 'Lee';
        
        foo = null;
        // 이전 참조를 제거. foo 변수는 더 이상 'Lee'를 참조하지 않는다.
        // 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어
        // 변수 자체를 재빨리 소멸시키는 편이 낫다.
        ```
        
        - 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 한다.
            - HTML 요소를 검색해 반환하는 `document.querySelector`메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우, 에러 대신 `null`로 반환한다.
            
    - symbol type : ES6에서 추가된 7번째 타입 (33장 참고)
        - `symbol` : 변경 불가능한 원시 타입의 값
        - 심벌 값은 다른 값과 중복되지 않는 유일무의한 값이므로 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
        
        - 심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 `Symbol` 함수를 호출해 생성한다.
            - 이때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무의한 값이다.
        
        ```jsx
        // 심벌 값 생성
        var key = Symbol('key');
        console.log(typeof key);    // symbol
        
        // 객체 생성
        var obj = {};
        
        // 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
        obj[key] = 'value';
        console.log(obj[key]);   // value
        ```
        

- 객체 타입(object, reference type) : 객체, 함수, 배열
    
    > “자바스크립트를 이루고 있는 거의 모든 것이 객체!!”
    > 
    - 테이터 타입의 필요성
        - 테이터 타입에 의한 메모리 공간의 확보와 참조
            - 메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 하는데, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지를 알아야 한다.
            - `var score = 100;`
                - 과정 : 메모리 공간 확보 → 확보된 메모리에 숫자 값 100을 2진수로 저장
                - 숫자 값 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 함!
                    - JS 엔진은 데이터 타입, 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
                    - 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
                - JS는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동 수서점 형식을 사용한다.
                    - 실제로 메모리에 저장되는 2진수 값은 책의 예제 그림과 다르다. (간단히 양의 정수로 저장된다고 생각하자.)
            
            <aside>
            💡 데이터 타입에 따라 확보되는 메모리 공간의 크기
            
            ECMAScript 사양 : 문자열과 숫자 타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지 않아서, 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간의 크기는 JS 엔진 제조사의 구현에 따라 다를 수 있다.
            
            단, ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 명시되어 있고, 배정밀도 64비트 부동소수점 형식은 8바이트로 숫자를 표현한다.
            
            </aside>
            
            - 컴퓨터는 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 아는가?
                - 변수에는 숫자 타입의 값이 할당되어 있으므로, JS 엔진은 `score` 변수를 숫자 타입으로 인식한다.
                - 숫자 타입은 8바이트 단위로 저장되므로, `score` 변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다.
        
        <aside>
        💡 심벌 테이블
        
        컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.
        
        </aside>
        
        - 데이터 타입에 의한 값의 해석
            - 그러면 메모리에 읽어 들인 2진수를 어떻게 해석해야 하는가?
            - 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 비트의 나열로 저장된다.
                - 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.
            - 앞서 살펴본 예제의 `score` 변수에 할당된 값은 숫자 타입의 값이다. 따라서 `score` 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석한다.
        
        - 정리
            - 데이터 타입은 값의 종류를 말함
            - JS의 모든 데이터 값은 데이터 타입을 갖는다.
            - 데이터 타입이 필요한 이유
                - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정하기 위해**
                - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기를** 결정하기 위해
                - 메모리에서 읽어 들인 **2진수를 어떻게 해석**해야 할지 결정하기 위해
                
    - 동적 타이핑
        - 동적 타입 언어와 정적 타입 언어
            - C, Java 같은 정적 타입(static/strong type) 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 데이터 타입을 사전에 선언해야 한다.
                - 이를 명시적 타입 선언(explicit type declaration)이라고 한다.
            - 정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
            - 정적 타입 언어는 컴파일 시점에 타입 체크를 수행한다.
                - 타입 체크 : 선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리
                - 타입 체크를 통과하지 못했다면 에러를 발생 → 프로그램  실행 자체를 막음
            - ex : C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등
            
            - JS는 정적 타입과 다르게 변수를 선언할 때 타입을 선언하지 않는다.
                - 다만, `var`, `let`, `const` 키워드를 사용해 변수를 선언
                - JS 변수는 정적 타입 언어와 같이 미리선언한 데이터 타입의 값만 할당할 수 있는 것이 아님. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
                
            - 변수를 하나 선언하고 지금까지 살펴본 다양한 데이터 타입의 값을 할당한 다음, `typeof` 연산자로 변수의 데이터 타입을 조사해보자.
                - `typeof` 연산자는 연산자 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환함
                
                ```jsx
                var foo;
                console.log(typeof foo);    // undefined
                
                foo = 3;
                console.log(typeof foo);    // number
                
                foo = 'Hello';
                console.log(typeof foo);    // string
                
                foo = true;
                console.log(typeof foo);    // boolean
                
                foo = null;
                console.log(typeof foo);    // object
                
                foo = Symbol();  // 심벌
                console.log(typeof foo);    // symbol
                
                foo = {};    // object
                console.log(typeof foo);    // object
                
                foo = [];    // 배열
                console.log(typeof foo);    // object
                
                foo = function () {};
                console.log(typeof foo);    // function
                ```
                
                - `typeof` 연산자로 변수를 연산하면 변수의 데이터 타입을 반환한다.
                    - (정확히는) 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것
                - JS 변수엔 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다름
                    - 정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고 변수의 타입을 변경할 수 없는데 비해, JS에선 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 변경할 수 있다.
                    
            
            > “JS 변수는 선언이 아닌 할당에 의해 타입이 결정(type inference)된다.”
            ”그리고 재할당에 의해 변수의 타입은 언제나 동적으로 변할 수 있다.”
            > 
            - 이러한 특징을 동적 타이핑(dynamic typing)이라고 하고, JS를 정적 타입 언어와 구별하기 위해서 동적 타입(dynamic/weak type)언어라고 한다.
            - ex : php, js, python, ruby, Perl 등
            
        - 동적 타입 언어와 변수
            - 동적 타입 언어는 변수에 어떤 데이터 타입의 값이더라도 자유롭게 할당할 수 있다.
                - 이런 언어를 계속 사용하게 되면 데이터 타입에 대해 무감각해질 정도로 편리해지지만, 편리함의 이면엔 위험이 있다는 것을 기억해야 한다.
                - 위험이란
                    - 모든 소프트웨어 아키텍처엔 트레이드오프(trade-off)가 존재하며, 모든 애플리케이션에 적합한 은 탄환은 없듯이 동적 타입 언어 또한 구조적 단점이 있음
                        - trade-off
                            - 두 개의 정책이나 목표 중 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계를 의미한다.
                            - ex : 실업률 줄이면 → 물가 상승, 물가 안정 → 실업률 높아짐
                        - 은 탄환 : 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책
                    - 변수 값은 언제든지 변경될 수 있어 복잡한 프로그램에선 변환하는 변수 값을 추적하기 어려울 수 있고, 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
                        - 동적 타입 언어의 변수는 값을 확인하기 전엔 타입을 확신할 수 없다.
                    - JS는 개발자의 의도와는 상관없이 JS 엔진에 의해 암묵적으로 타입이 자동 변환되기도함
                        - 숫자 타입의 변수이라고 예측했지만 문자열 타입의 변수일 수도 있다는 말 (”1”을 1로 판단하는 것)
                    - 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 뽑아낼 것임
                    - 따라서, 동적 타입 언어는 유연성(fiexbility)은 높지만 신뢰성(reliability)은 떨어짐
            
            - 그래서, 안정적인 프로그램을 만들기 위해 변수를 사용하기 이전에 데이터 타입을 체크해야 하는 경우가 있는데, 이는 매우 번거롭고 코드의 양도 증가하게 된다.
            
            - 따라서 변수를 사용할 때 주의해야 할 사항!!
                - 변수는 꼭 필요한 경우에 한해 제한적으로 사용!
                    - 변수 값은 재할당에 의해 언제든지 변경될 수 있음
                        - 위로 인해서 동적 타입 언어(JS)는 타입을 잘못 예측하여 오류가 발생할 가능성이 큼
                    - 변수의 개수가 많으면 많아질수록 오류 발생 확률 높아져 변수의 무분별한 남발은 하지 말고, 필요한 만큼 최소한으로 유지하도록 주의해야 한다.
                - 변수의 유효 범위(scope)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. (13장 참고)
                    - 변수의 유효범위 넓어질수록 변수로 인해 오류 발생 확률이 커짐
                - 전역 변수는 최대한 사용하지 않도록 하자. (14장 참고)
                    - 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고, 다른 코드에 영향을 줄 가능성도 높다.
                    - 전역 변수는 프로그램의 복잡성을 증가시키고 처리 흐름을 추적하기 어렵게 만들고, 오류가 발생할 경우 오류의 원인을 특정하기 어렵게 만든다.
                - 변수보단 상수를 사용해 값의 변경을 억제한다. (15.3절 참고)
                - 변수 이름은 변수의 어떤 목적이나 의미를 파악할 수 있도록 네이밍한다.
                    - 변수 뿐만 아니라 모든 식별자는 존재 이유를 파악할 수 있는 적절한 이름으로 네이밍해야 한다.
                    - 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들고, 이는 협업과 생산성 향상에 도움을 준다.
                        - 변수 이름 짓는거 매우 중요함!!
                    
- 코드는 오해하지 않도록 작성해야 함
    - 오해 → 커뮤니케이션 저하 → 생산성 저하 → 팀의 사기 저하
    - 따라서!! 가독성이 좋은 코드를 짜는 데 집중을 먼저 해야 한다.
    
    *“컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.” - 마틴 파울러(Martin Fowler) <리팩토링>*