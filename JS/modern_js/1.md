# 1. intro (1 ~ 3)
## 1. 프로그래밍

- 프로그래밍이란
    - 프로그래밍 : 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션
        - 요구되는 것 : 문제 해결 능력
        - 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 **정확하고 상세하게 요구사항을 설명**하는 작업으로, 그 결과물이 코드이다.
    
    - 컴파일러 (compiler)
        - 컴파일 : 어떤 언어의 코드를 다른 언어로 바꿔주는 과정
        - 컴파일러 : 어떤 프로그래밍 언어로 쓰여진 소스 파일을 다른 프로그래밍 언어로 바꾸어주는 번역기
    - 인터프리터(interpreter)
        - 코드를 한 줄씩 읽어 내려가며 실행하는 프로그램
        - 프로그래밍 언어의 설계가 쉬워서 인터프리터 언어가 많아졌다.
    
    - 컴파일러(번역기)와 인터프리터(해석)를 사용하여 사람이 작성한 프로그래밍 언어를 컴퓨터가 이해할 수 있는 기계어로 번역한다.
    - 자연어와 인공어
        - 자연어 : 프로그래밍 언어와 반대되는 개념으로, 우리(사람)가 사용하는 언어
        - 인공어 : 프로그래밍 언어에 해당되며, 컴퓨터와의 대화(명령)에 사용되는 언어이다.
            - 사람과 컴퓨터(컴파일러 또는 인터프리터) 모두가 이해할 수 있는 약속된 형태의 인공어
            
- 구문과 의미
    - 프로그래밍 언어는 구문(syntax)과 의미(sementics) 조합으로 이루어져 있다.
    - 그러므로, 문법에 맞는 문장을 구성하는 것은 물론 의미를 가지고 있어야 언어의 역할을 충실히 수행할 수 있다.
    
    - JS의 변수에는 어떠한 타입의 값도 할당할 수 있다.
        - 문법적으로 전혀 문제가 없더라도, 의미적으로 옳지 않은 경우도 있다.
    
    - 문제 해결 능력을 통해 만들어낸 해결 방안은 프로그래밍 언어의 문법을 사용해 표현한다.
        - 즉, 작성된 코드는 해결 방안의 구체적 구현물이다.
        - 그리고 이것을, 프로그래밍 언어의 문법에 부합하는 것은 물론이고 수행하고자 하는 바를 정확히 수행하는 것, 즉 **요구사항이 실현(문제가 해결)** 되어야 의미가 있다.
        
    
    > “프로그래밍의 목적은 문제해결”


<aside>
💡 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것
</aside>

## 2. JS란?

- JS의 탄생
    - 1995, 넷스케이프의 브렌던 아이크가 개발한 언어
        - 당시, 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기로 하였음
    - JS는 현재 모든 브라우저의 표준 프로그래밍 언어로 자리 잡음
    
- JS의 표준화
    - 1996, 8, MS는 js의 파생 버전인 “JScript”를 Internet Explorer에 탑재하면서, 넷스케이프와 MS는 각자의 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작하면서..
    **크로스 브라우징 이슈**가 발생하기 시작했다.
        - 크로스 브라우징 이슈 : 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 이슈
        - 이로 인해 모든 브라우저에서 정상적으로 동작하는 웹페이지를 개발하기가 어려워짐
    
    - JS의 파편화 방지 + 모든 브라우저 정상적 동작 ⇒ 표준화된 JS 필요해짐
        - 1996, 11 넷스케이프가 ECMA에 JS의 표준화를 요청하였고, 1997, 7에 표준화된 자바스크립트 ECMAScript로 명명됨 (상표궈너 문제로 인해)
    
    - ES6(ECMA 2015)는 let, const 키워드, 화사푤 함수, 클래스, 모듈 등과 같이 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입하면서 큰 변화가 있었음

- JS 성장의 역사
    - 초창기 JS는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용됨
        - 대부분의 로직 : 웹 서버에서 실행
        - 브라우저 : 서버로부터 전달받은 html, css를 단순히 렌더링하는 수준이었음
        - **렌더링(rendering)**
            - HTML, CSS, JS로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것
            - 때론, 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정 (SSR; Server Side Rendering)을 가리키기도 함
        
    - Ajax
        - Ajax : Asynchronous JS and XML, 자바스크립트를 이용해 서버와 브라우저기 **비동기(asynchronous)** 방식으로 데이터를 교환할 수 있는 통신 기능
        - Ajax가 XMLHttpRequest라는 등장 이름으로 등장했음
        - before
            - html 태그로 시작해서 html 태그로 끝나는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작했음
            - 화면이 전환되면 서버로부터 새로운 HTML을 전송 받아 웹페이지 전체를 처음부터 다시 렌더링했음
            - 단점
                - 전송할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문에 불필요한 데이터 통신이 발생
                - 변경할 필요가 없는 부분가지 처음부터 다시 렌더링해야 하므로 성능면에서도 불리함
                    - 화면이 전환되면 화면이 순간적으로 깜박이는 현상이 발생하고, 이는 웹페이지의 어쩔 수 없는 한계로 받아들여짐
        - after
            - 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해짐
            - 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 성능과 부드러운 화면 전환이 가능해졌다.
            
    - jQuery
        - 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 되었음
        - 크로스 브라우징 이슈도 어느정도 해결됨
        - 넓은 사용자 층을 순식간에 확보했음
            - 배우기 까다로운 js보단 jQuery를 더 선호하는 개발자가 많아짐
            
    - V8 자바스트립트 엔진
        - 더욱 빠르게 동작하는 js 엔진의 필요성이 대두되면서 구글이 개발한 엔진
        - V8 엔진의 등장으로, JS는 데스크톱 Application과 유사한 UX을 제공할 수 있는 웹 Application 프로그래밍 언어로 정착하게 됨
        - V8 엔진으로 촉발된 JS의 발전으로 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동했고, 웹 애플리케이션 개발에서 프론트엔드 영역이 주목받게 된 계기가 됨
        
    - Node.js
        - V8 엔진으로 빌드된 JS 런타임 환경
        - Node.js는 브라우저의 JS 엔진에서만 동작하던 JS를 브라우저 이외의 환경에서도 동작할 수 있도록 JS 엔진을 브라우저에서 독립시킨 JS 실행 환경
        - 다양한 플랫폼에 적용할 수 있지만, 서버 사이드 애플리케이션 개발에 주로 사용되며, 이에 필요한 모듈, 파일 시스템, HTTP 등 Bulit-in API를 제공함
        
        - Node.js 환경에서 동작하는 애플리케이션은 JS를 사용해 개발할 수 있다.
            - fe, be 영역에서 js를 사용할 수 있다는 동형성(isomorphic)은 별도의 언어를 학습하기 위한 시간을 덜 수 있다.
        
        - Node.js는 비동기 I/O를 지원하며, **단일 스레드 이벤트 루프** 기반으로 동작함으로써, 요청(request) 처리 성능이 좋다.
            - Node.js는 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA(Single Page Application)에 적합하다.
            - 하지만, CPU 사용률이 높은 애플리케이션엔 권장하지 않음
            
        - Node.js 등장으로 JS는 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용할 수 있는 범용 프로그래밍 언어가 되엇음
        - JS는 **크로스 플랫폼**을 위한 가장 중요한 언어로 주목받게 됨
    
    - SPA 프레임워크
        - 이전 개발 방식으론 복잡해진 개발 과정을 수행하기 어려워졌고, 이런 필요에 따라 많은 패턴과 라이브러리가 출현했다.
            - 개발에 많은 도움을 주었지만, 변경에 유연하면서 확장하기 쉬운 Application 아키텍처 구축을 어렵게 했고, 필연적으로 프레임워크가 등장하게 되었음
        - 이런 요구에 맞춰, CBD 방법론을 기반으로 하는 SPA가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리 또한 많은 사용층을 확보하고 있다.
            - CBD 방법론
                - Component Based Development ; 컴포넌트 기반 개발방법론
                - 컴포넌트를 조합해 재사용함으로써 개발 생산성과 품질을 높이고 시스템 유지보수 비용을 최소화할 수 있는 개발 방법론
                    - 다음으로 인하여 등장함
                        1. 기업환경 변화에 따른 소프트웨어 대형화, 복잡화 현상이 발생화
                        2. 복잡성과 유지보수 비용의 증가 : 70% 이상의 유지보수 비용을 요구함
                        3. 개발 생산성 향상과 높은 질의 소프트웨어를 요구함
                        4. 객체지향 방법은 단일 언어로 개발하고, 수시로 모듈을 수정하여 재컴파일해야 하는 불편함이 있음
                        
- JS와 ECMAScript
    - ECMAScript = ECMA-262, 자바스크립트 표준 사양을 의미
    - JS : ECMAScript (Core), + 브라우저가 별도 지원하는 **클라이언트 사이드 Web API**
        - 클라이언트 사이드 Web API 종류
            - DOM, BOM, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등
            - 월드 와이드 웹 컨소시엄에서 별도의 사양으로 관리하고 있음
            
- JS 특징
    - 웹을 구성하는 3대 요소 중 하나
    - 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
    - 기본 문법 : C, java
        - self : 프로토타입 기반 상속
        - Scheme : 일급 함수 개념 차용
    - 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**
        - 모던 자바스크립트 엔진(크롬 - V8, 파이어폭스 - SpiderMonkey, 사파리 - JavaScriptCore, MS Edge - Chakra 등)은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했음
    
    | 컴파일러 언어 | 인터프리터 언어 |
    | --- | --- |
    | 코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신 코드로 변환한 후 실행 | 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트 코드로 변환한 후 실행 |
    | 실행 파일을 생성함 | 실행 파일을 생성하지 않음 |
    | 컴파일 단계와 실행 단계가 분리되어 있음. 
    명시적인 컴파일 단계를 거치고, 명시적으로 실행 파일을 실행한다. | 인터프리트 단계와 실행 단계가 분리되어 있지 않다.
    인터프리터는 한 줄씩 바이트코드로 변환하고 즉시 실행한다. |
    | 실행에 앞서 컴파일은 단 한번 수행된다. | 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. |
    | 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다. | 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. |
    - 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일러 언어처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스를 컴파일하고 실행한다.
        - 이를 통해, 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리단 단점을 극복함
        - 현재는 컴파일러와 인터프리터의 기술적 구분이 점차 모호해져 가지만, JS는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없으므로 컴파일 언어라고 할 수 없다.
    
    - JS = 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍 지원
        - 멀티 패러다임 프로그래밍 언어
        - (논쟁은 있지만) JS는 강력한 객체지향 프로그래밍 능력을 가지고 있음
        - JS는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 **프로토타입 기반의 객체지향 언어**
        
- ES6 브라우저 지원 현황
    - IE를 제외한 대부분의 모던 브라우저는 ES6을 지원, 하지만 100% 지원하고 있지는 않다.
        - IE나 구형 브라우저를 고려해야 하는 상황이면, Babel과 같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 ES5 이하의 사양으로 다운그레이드할 필요가 있음

## 3. JS 개발 환경과 실행 방법

- JS 실행 환경
    - 모든 브라우저엔 JS 엔진을 내장하고 있음
        - Node.js, 브라우저 환경에서 실행 가능하고, 동일하게 동작한다.
    - Node.js와 브라우저는 용도가 다르다는 것을 주의해야 한다.
        - 브라우저 : HTML, CSS, JS를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적
        - Node.js : 브라우저 외부에서 JS 실행 환경을 제공하는 것이 주 목적
        - 브라우저 + Node.js ⇒ ECMAScript 실행 가능
        - ECMAScript 이외에 추가로 제공하는 기능은 브라우저와 Node.js끼리 호환되지 않음
            - ex : DOM API (브라우저에만 있음)
            
            <aside>
            💡 웹 크롤링
            - 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML 문서를 가져온 다음, 이를 가공해서 필요한 데이터만 추출하는 경우
            - 서버 환경은 DOM API를 제공하지 않아서 cheerio 같은 DOM 라이브러리를 사용해 HTML 문서를 가공하기도 함
            
            </aside>
            
    - 웹 Application JS는 사용자 컴퓨터 브라우저에서 동작하는데, 브라우저를 통해 다운로드되어 실행되는 JS가 사용자 컴퓨터의 로컬 파일을 삭제하거나 수정하고 생성할 수 있다면, 사용자 컴퓨터가 악성 코드에 그대로 노출된 것과 마찬가지이므로, **보안상의 이유로 브라우저 환경의 JS는 파일 시스템을 제공하지 않음**
    
    - 브라우저 : 클라이언트 사이드 Web API + ECMAScript
    - Node.js : Node.js 고유의 API + ECMAScript

- 웹 브라우저
    - 개발자 도구 (크롬)
        - 크롬 : ECMAScript 준수, 시장 점유율 높음, V8 자바스크립트 엔진은 Node.js에서도 사용함
        - Dev Tool은 웹 애플리케이션 개발에 필수적인 강력한 도구임
            - 자주 사용하는 개발자 도구의 기능
            - Element
                - 로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인할 수 있음
                - 단, 편집한 내용이 저장되지는 않는다.
                - 웹 페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인해 유용한 힌트를 얻을 수 있다.
            - Console
                - 로딩된 웹페이지의 에러를 확인하거나 JS 소스코드에 작성한 `console.log`메서드 실행 결과를 확인할 수 있다.
            - Sources
                - 로딩된 웹페이지의 JS 코드를 디버깅할 수 있다.
            - Network
                - 로딩된 웹페이지에 관련된 네트워크 요청 (request) 정보와 성능을 확인할 수 있다.
            - Application
                - 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.
    - 콘솔 (Dev Tool의 console 패널)
        - JS 코드에서 에러가 발생해 Application이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳
        - 콘솔을 열어두지 않음 에러가 발생했는지조차 알 수 없는 경우도 있음
        - 콘솔은 JS 코드를 직접 입력해 그 결과를 확인할 수 있는 REPL(Real Eval Print Loop ; 입력 수행 출력 반복) 환경으로 사용할 수도 있음
        - 한 줄로만 작성을 할 수 있는데, 여러 줄로 이뤄진 JS 코드를 실행할 때 줄바꿈이 필요한 경우엔 Shift + Enter
        
    - 브라우저에서 JS 실행
        - 브라우저는 HTML 파일을 로드하면 script 태그에 포함된 JS 코드를 실행함
        

- Node.js
    - 프로젝트의 규모가 커짐에 따라 React, Angular, Lodash같은 프레임워크 또는 라이브러리를 도입하거나 Babel, Webpack, ESLint 등 여러 가지 도구를 사용할 필요가 있는데, 이때 Node.js와 npm이 필요하다.
    
    - Node.js, npm 소개
        
        Node.js
        
        - Node.js는 크롬 V8 JS 엔진으로 빌드돤 JS 런타임 환경
        - 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 JS 실행 환경
        
        npm
        
        - node package manager, 자바스크립트 패키지 매니저
        - Node.js에서 사용할 수 있는 모듈들을 패키니에서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공함
        
    - Node.js 설치
        - Node.js : LTS, Current
            - LTS : 장기적으로 안정된 지원이 보장됨
            - Current : 최신 기능을 제공하지만 업데이트가 발생하는 버전으로 안정적이지 않을 수도 있음
        - 설치 후, cmd에 다음과 같이 입력해서 버전 확인해보자.
            
            ```
            $ node -v
            v14.3.0
            $ npm -v
            6.14.5
            ```
            
    - Node.js REPL
        - REPL(Read Eval Print Loop)을 사용하면 간단한 JS 코드를 실행해 결과를 확인해 볼 수 있음
            - `$ node`
        - JS 파일을 실행하려면 `node` 명령어 뒤에 파일 이름을 입력한다. (확장자 `.js`는 생략해도 됨)
        - Ctrl + C 두번 입력하면 REPL 종료됨
- VSCode
    - Code Runner 확장 플러그인
        - Code Runner 확장 플러그인을 사용하면 VSCode의 내장 터미널에서 단축키를 사용해 JS를 비롯해 다양한 프로그래밍 언어로 구현된 소스코드를 간단히 실행할 수 있다.
        - VScode → Code Runner 설치 → `Ctrl + Alt + N` 단축키를 이용하여 JS 파일을 실행할 수 있다.
        - 참고 : `alert()` 는 브라우저에서만 동작하는 클라이언트 사이트 Web API이다.
            - Code Runner 확장 플러그인은 Node.js 환경을 사용해 JS를 실행하는데, Node.js 환경에서 알 수 없으므로 에러가 발생한 것임
            - 클라이언트 사이드 Web API가 포함된 소스코드는 브라우저 환경에서 실행해야 함.
    
    - Live Server 확장 플러그인
        - 클라이언트 사이즈 Web API가 포함된 JS 코드를 실행하려면 Node.js 환경이 아니라 브라우저 Dev Tool console에서 실행하거나 JS를 HTML에 삽입한 다음 HTML 파일을 브라우저에서 열어야 한다.
        - 이러한 과정을 거치게 되면 파일 경로 문제가 발생할 수 있고, 소스코드를 수정할 때 매번 새로고침해야 하므로 번거롭다.
            - 그럴 때 Live Server 확장 플러그인을 이용하면 된다.
            - Live Server 확장 플러그인을 이용하면 소스코드를 수정할 때마다 수정 사항을 브라우저에 자동으로 반영해주므로 매우 편리하다.
        - VSCode → Live Server 설치 → 화면 아래에 Go Live이란 버튼이 생김
            - Go Live 버튼을 클릭하면, 가상 서버가 가동되어 브라우저에 HTML 파일이 자동으로 로딩된다.
            - 이후, 소스코드를 수정하면 수정 사항이 가상 서버에 자동으로 반영된다.